# Bevezetés a típuselmélet világába

A tipuselmélet (*type theory*) tárgy során célunk az *Agda* programozási nyelv nyelvi konstrukcióinak és lehetőségeinek megismerése és ezek elsajátításával matematikai struktúrák programozása, bizonyítások ellenőrzése.

A legtöbb modern programozási nyelv típusozott, ezek közül is az erősen típusozott programozási nyelvek fordítója képes arra, hogy a típusos program annak a típusokkal megadott specifikációjának megfeleljen(avagy pongyolán fogalmazva, minden helyen olyan típust használjunk, mint amit ott szabad). A fordítóprogram automatikusan elvégzi a típusellenőrzést, és ha nem típushelyes a program, visszautasítja a megfelelő hibaüzenettel.

A matematika *Zermelo-Fraenkel* halmazelméletet és az elsőrendű logikát használja építőkővekként, a matematikai modellek ezek használatával készül. A programozáson kívül a matematikában is léteznek típusok, illetve típusrendszerek. A típuselmélet egy alternatívát kínál, úgy, hogy nem használja az előbb említett építőköveket. Ezek helyett a matematikai típusok használatával építi fel a matematikai modelleket.

Ezen elméletekben egy-egy matematikai entitás(pl. fogalom, probléma stb.) felel meg egy-egy típusnak. Egy típust az altípusainak segítségével tudunk definiálni, ezzel elkerülve azt a problémát, hogy egy típust saját magával definiáljunk.

A tárgy keretein belül a Martyn-Löf típuselmélettel fogunk foglalkozni, melynek 3 alap entitása van.

1. üres típus/entitás  
    Nincs eleme, nem tudunk olyan kifejezést megadni, mely eleme lenne.  
    Jele: ⊥ elnevezése: *bottom*

2. egyelemű típus/entitás  
    Pontosan egy eleme van, melyet a nyelv használata közben tt-vel lehet majd elérni.  
    Jele: ⊤ elnevezése: *top*

3. kételemű típus/entitás  
    Pontosan két eleme van, ez egy egyértelmű választást jelent a két érték között.  
    Egyszerű példa rá a Bool típus, mely egyértelműen vagy true értéket vesz fel, vagy false értéket.

Az agda azon kívül, hogy implementálja a *ML típuselméletet*, hozzáadja **λ-kalkulus**t is.

A **λ-Kalkulus** egy *turing teljes formális rendszer a matematikai logikában*. λ-kalkulus több egyszerűsítést is behoz szemantikában:

- kódolás során **névtelen függvények**et használunk
Példa: id(x) = x átírható λ x → x
- a függvények egy paraméterrel rendelkeznek, egy több paraméteres függvényt szét tudunk **bontani több egy paraméteres** függvényre. 
Példa: Multiply(x,y) = x * y átalakítható λ x → (λ y → x * y) ahol a külső függvény egy másik függvényt ad paraméternek.
A szétbontás folyamatát **curryzésnek** hívjuk, mely maga is egy függvény.
- tudunk függvényeket **parciálisan alkalmazni**, azaz egy több paraméteres függényt úgy meghívni, hogy annak nem az összes paraméterét kapjuk meg.
Példa: _ + _ : ℕ → (ℕ → ℕ), viszont 3 + _ : ℕ → ℕ , mely már csak egy számot vár.

**Redukciók**
*A következő műveletek a λ-kalkulus során segítenek abban, hogy a kifejezést egyszerűbb alakra hozzuk, vagy pedig olyan alakra, amiről már tudunk valamit. A műveletekről részletesen a következő órai jegyzetben lesz szó.*

- **β redukció** / β szabály
A *β szabály* a függvény alkalmazás ötletét hozza be a λ-kalkulus világába. Ha van egy függvényünk és a hozzá tartozó paraméter, akkor a függvényben az ismeretleneket behelyettesítjük a kapott paraméterrel.
Például: (λx → x + 1) 2 → (2 + 1) → 3
- **η(éta) redukció** / η szabály
Az *η szabály* célja, az extenzionalitás megvalósítása, azaz hogy a függvények, melyek pontok szerint egyeznek, de a definíciójuk különböző, ne tegyünk különbséget.
Például: (λ x → f x) = f
- **α szabály** / α egyenlőség / változó szabály
Az *α szabály* célja hogy a változókat szabadon át tudjuk nevezni a kifejezésünkben anélkül, hogy a kifejezés lényegében változna.
Például: (λ x → λ y → x + y) → α szabály → (λ a → λ b → a + b)


**Izomorfizmus**
*A tárgy során amikor izomorfizmusról beszélünk, a Curry–Howard izomorfizmust fogjuk érteni. Az izomorfizmust fel tudjuk majd használni különböző nyelvi elemek átalakítására, illetve ezzel tudunk majd logikai állításokat nyelvi elemeknek megfeleltetni*
Pongyolán fogalmazva : *Izomorfizmusnak azt nevezzük, ha két kifejezés gyakorlatilag ugyanazon információ eltárolására képes, azok között oda-vissza átjárható kapcsolat van*
